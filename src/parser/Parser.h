#pragma once

#include <string_view>
#include <string>
#include <sstream>
#include <unordered_map>
#include <chrono>
#include <ctime>

namespace dpl{
	class Parser {
	public:
		
		struct Options {
			unsigned char
				  log_step_by_step		: 1 = true
				, log_parse_tree		: 1 = true
				, log_errors			: 1 = true
				, log_tokenizer			: 1 = true
				, log_parse_table		: 1 = false
				, log_grammar			: 1 = false
				, log_grammar_info		: 1 = false
				, log_automaton			: 1 = false

				, log_to_file			: 1 = false;

			enum class ErrorMode { Ignore, StopAtFirst, RecoverOnFollow, RepairOnFollow } error_mode = ErrorMode::Ignore;
			std::filesystem::path log_dir = std::filesystem::current_path() / "/dyppyl_log.txt";

		};

		class RunOptions : public Options {
		public:

			RunOptions(const Options& ops) : Options(ops) { }

			bool is_logging_to_file() const { return log_to_file; }

			inline void logprint(std::string_view dest_name, auto str, auto... rest) {
				log_dests[dest_name] << dpl::log::streamer{ str };
				if constexpr (sizeof...(rest) > 0) {
					logprint(dest_name, rest...);
				}
			}

			inline void logprintln(std::string_view dest_name, auto... strs) {
				logprint(dest_name, strs..., '\n');
			}

			void flush_logs() {
				std::ostream* log_dest;
				if (log_to_file) {
					if (!log_dir.is_absolute()) {
						auto abs_dir = std::filesystem::current_path();
						abs_dir += "/";
						abs_dir += log_dir;

						log_dir = abs_dir.make_preferred();
					}
					if (!log_dir.has_filename()) log_dir /= "dyppyl_log.txt";

					auto path_to = log_dir.parent_path();
					std::filesystem::create_directories(path_to);

					log_dest = new std::ofstream(log_dir);
				} else log_dest = &std::cout;


				auto now = std::chrono::system_clock::now();
				std::time_t now_time = std::chrono::system_clock::to_time_t(now);

				struct tm buf;
				localtime_s(&buf, &now_time);

				*log_dest << "Dyppyl Parse Log,\n"
						  << "Generated by Dyppyl at "
						  << std::put_time(&buf, "%T %F")
						  << "\n\n" << std::flush;

				for (const auto& [header, contents] : log_dests) {
					*log_dest << header << ":\n" << contents.str() << "\n\n";
				}

				if (log_to_file) delete log_dest;

				log_dests.clear();
			}

		private:

			using Options::log_to_file;
			std::unordered_map<std::string_view, std::stringstream> log_dests;
			friend dpl::Parser;

		};

		Parser(Grammar& g, const Options& ops = {}) : grammar(g), tokenizer(grammar), options(ops) { }

		ParseTree parse(dpl::TextStream& src) {
			parse_init();

			tokenizer.tokenize(src, [this](const Token& tkn) {
				if (options.log_tokenizer)
					options.logprintln("Tokenizer Output", tkn, " at ", tkn.pos);

				*this << tkn;
			});

			if (options.log_parse_tree)
				options.logprintln("Parse Tree", out_tree);

			if (options.log_grammar)
				options.logprintln("Grammar", grammar);
			if (options.log_grammar_info) {
				options.logprint("Grammar", "\n\nFirst Sets:");
				for (const auto& [nonterminal, terminals] : grammar.firsts) {
					options.logprint("Grammar", "\n", nonterminal, ": ", terminals);
				}

				options.logprint("Grammar", "\n\n\Follow Sets:");
				for (const auto& [nonterminal, terminals] : grammar.follows) {
					options.logprint("Grammar", "\n", nonterminal, ": ", terminals);
				}
			}

			options.flush_logs();

			return std::move(out_tree);
		}

		RunOptions options;

	protected:

		inline void err_unexpected_token(const dpl::Token& tkn) {
			if (options.log_errors)
				options.logprintln("Errors", "syntax error: unexpected token ", tkn, " at position (", dpl::log::streamer{ tkn.pos }, ")");
		}

		virtual TreeBuilder& tree_builder() = 0;
		virtual void operator<<(const Token&) = 0;
		virtual void parse_init() = 0;

		Grammar& grammar;
		ParseTree out_tree;
		Tokenizer tokenizer;

	};
}