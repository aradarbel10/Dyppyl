#pragma once

#include <string_view>
#include <string>
#include <sstream>
#include <unordered_map>
#include <set>
#include <chrono>
#include <ctime>
#include <filesystem>

#include "../ParseTree.h"

namespace dpl{

	template<typename GrammarT = dpl::Grammar<>, typename LexiconT = dpl::Lexicon<>>
	class Parser {
	public:

		using grammar_type = GrammarT;
		using lexicon_type = LexiconT;
		
		using atom_type = lexicon_type::atom_type;
		using span_type = lexicon_type::span_type;

		using token_type = grammar_type::token_type;
		using nonterminal_type = grammar_type::nonterminal_type;

		using terminal_type = token_type::terminal_type;
		using terminal_name_type = token_type::name_type;

		using tree_type = dpl::ParseTree<grammar_type>;

		struct Error {
			token_type found;
			std::set<terminal_type> expected;
		};

		struct Options {
			unsigned char
				  log_step_by_step		: 1 = false
				, log_parse_tree		: 1 = false
				, log_errors			: 1 = false
				, log_tokenizer			: 1 = false
				, log_parse_table		: 1 = false
				, log_grammar			: 1 = false
				, log_grammar_info		: 1 = false
				, log_automaton			: 1 = false

				, log_to_file			: 1 = false;

			enum class ErrorMode { Ignore, Panic, RepairOnFollow } error_mode = ErrorMode::Ignore;
			std::filesystem::path log_dir = std::filesystem::current_path() / "/dyppyl_log.txt";

		};

		class RunOptions : public Options {
		public:

			RunOptions(const Options& ops) : Options(ops) { }

			bool is_logging_to_file() const { return log_to_file; }

			inline void logprint(std::string_view dest_name, auto str, auto... rest) {
				log_dests[dest_name] << dpl::streamer{ str };
				if constexpr (sizeof...(rest) > 0) {
					logprint(dest_name, rest...);
				}
			}

			inline void logprintln(std::string_view dest_name, auto... strs) {
				logprint(dest_name, strs..., '\n');
			}

			void flush_logs() {
				if (log_dests.empty()) return;

				std::ostream* log_dest = nullptr;
				if (log_to_file) {
					if (!this->log_dir.is_absolute()) {
						auto abs_dir = std::filesystem::current_path();
						abs_dir += "/";
						abs_dir += this->log_dir;

						this->log_dir = abs_dir.make_preferred();
					}
					if (!this->log_dir.has_filename()) this->log_dir /= "dyppyl_log.txt";

					auto path_to = this->log_dir.parent_path();
					std::filesystem::create_directories(path_to);


					auto now = std::chrono::system_clock::now();
					std::time_t now_time = std::chrono::system_clock::to_time_t(now);

					struct tm buf;
					localtime_s(&buf, &now_time);

					log_dest = new std::ofstream(this->log_dir);

					*log_dest << "Dyppyl Parse Log,\n"
						<< "Generated by Dyppyl at "
						<< std::put_time(&buf, "%T %F")
						<< "\n\n" << std::flush;
				} else log_dest = &std::cout;

				for (const auto& [header, contents] : log_dests) {
					*log_dest << header << ":\n" << contents.str() << "\n\n";
				}

				if (log_to_file) delete log_dest;

				log_dests.clear();
			}

		private:

			using Options::log_to_file;
			std::unordered_map<std::string_view, std::stringstream> log_dests;
			friend dpl::Parser<grammar_type>;

		};

		Parser(grammar_type& g, lexicon_type& l, const Options& ops = {}) : grammar(g), lexicon(l), tokenizer(lexicon), options(ops) { }

		std::pair<tree_type, std::vector<Error>> parse(span_type src) {
			parse_init();

			errors.clear();
			fixed_last_error = true;

			tokenizer.tokenize(src, [&,this](const token_type& tkn) {
				if (options.log_tokenizer)
					options.logprintln("Tokenizer Output", tkn, " at ", tkn.pos);

				*this << tkn;
			});

			if (options.log_parse_tree)
				options.logprintln("Parse Tree", out_tree);

			if (options.log_grammar)
				options.logprintln("Grammar", grammar);
			if (options.log_grammar_info) {
				options.logprint("Grammar", "\n\nFirst Sets:");
				for (const auto& [nonterminal, terminals] : grammar.get_firsts()) {
					options.logprint("Grammar", "\n", nonterminal, ": ", terminals);
				}

				options.logprint("Grammar", "\n\n\Follow Sets:");
				for (const auto& [nonterminal, terminals] : grammar.get_follows()) {
					options.logprint("Grammar", "\n", nonterminal, ": ", terminals);
				}
			}

			options.flush_logs();

			return std::move(std::pair{ out_tree, errors });
		}

		RunOptions options;

	protected:

		inline void err_unexpected_token(const token_type& tkn) {
			errors.push_back({tkn, currently_expected_terminals()});

			if (options.log_errors)
				options.logprintln("Errors", "syntax error: unexpected token ", tkn, " at position ", dpl::streamer{ tkn.pos });

			if (options.error_mode == Options::ErrorMode::Panic) fixed_last_error = false;
		}

		virtual TreeBuilder<grammar_type>& tree_builder() = 0;
		virtual void operator<<(const token_type&) = 0;
		virtual void parse_init() = 0;
		virtual std::set<terminal_type> currently_expected_terminals() const = 0;

		grammar_type& grammar;
		lexicon_type& lexicon;
		Tokenizer<atom_type, token_type> tokenizer;

		bool fixed_last_error = true;
		std::vector<Error> errors;
		tree_type out_tree;

	};
}